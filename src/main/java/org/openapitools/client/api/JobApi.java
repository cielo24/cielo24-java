/*
 * Cielo24
 * The cielo24 Web Services Platform API allows developers to easily integrate transcription, captioning and keyword extraction into their applications without having to use a manual web portal.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: devs@cielo24.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.AddMediaResponse;
import org.openapitools.client.model.ErrorResponse;
import java.io.File;
import org.openapitools.client.model.JobInfoResponse;
import org.openapitools.client.model.NewJobBody;
import org.openapitools.client.model.NewJobResponse;
import org.openapitools.client.model.PerformTranscriptionBody;
import org.openapitools.client.model.PerformTranscriptionResponse;
import org.openapitools.client.model.PerformTranslationResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class JobApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public JobApi() {
        this(Configuration.getDefaultApiClient());
    }

    public JobApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for addMediaFile
     * @param v  (required)
     * @param jobId  (required)
     * @param contentLength  (required)
     * @param body  (required)
     * @param isDuplicate  (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addMediaFileCall(Integer v, String jobId, Integer contentLength, File body, String isDuplicate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/job/add_media";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (v != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("v", v));
        }

        if (jobId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("job_id", jobId));
        }

        if (isDuplicate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("is_duplicate", isDuplicate));
        }

        if (contentLength != null) {
            localVarHeaderParams.put("Content-Length", localVarApiClient.parameterToString(contentLength));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "video/mp4"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call addMediaFileValidateBeforeCall(Integer v, String jobId, Integer contentLength, File body, String isDuplicate, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'v' is set
        if (v == null) {
            throw new ApiException("Missing the required parameter 'v' when calling addMediaFile(Async)");
        }
        
        // verify the required parameter 'jobId' is set
        if (jobId == null) {
            throw new ApiException("Missing the required parameter 'jobId' when calling addMediaFile(Async)");
        }
        
        // verify the required parameter 'contentLength' is set
        if (contentLength == null) {
            throw new ApiException("Missing the required parameter 'contentLength' when calling addMediaFile(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling addMediaFile(Async)");
        }
        

        okhttp3.Call localVarCall = addMediaFileCall(v, jobId, contentLength, body, isDuplicate, _callback);
        return localVarCall;

    }

    /**
     * 
     * Add a piece of media to an existing job using a local file. No content-type should be included in the HTTP header. The media should be uploaded as raw binary, no encoding (base64, hex, etc) is required. Chunk-transfer encoding is NOT supported. File size is limited to 10 gb
     * @param v  (required)
     * @param jobId  (required)
     * @param contentLength  (required)
     * @param body  (required)
     * @param isDuplicate  (optional, default to false)
     * @return AddMediaResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public AddMediaResponse addMediaFile(Integer v, String jobId, Integer contentLength, File body, String isDuplicate) throws ApiException {
        ApiResponse<AddMediaResponse> localVarResp = addMediaFileWithHttpInfo(v, jobId, contentLength, body, isDuplicate);
        return localVarResp.getData();
    }

    /**
     * 
     * Add a piece of media to an existing job using a local file. No content-type should be included in the HTTP header. The media should be uploaded as raw binary, no encoding (base64, hex, etc) is required. Chunk-transfer encoding is NOT supported. File size is limited to 10 gb
     * @param v  (required)
     * @param jobId  (required)
     * @param contentLength  (required)
     * @param body  (required)
     * @param isDuplicate  (optional, default to false)
     * @return ApiResponse&lt;AddMediaResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AddMediaResponse> addMediaFileWithHttpInfo(Integer v, String jobId, Integer contentLength, File body, String isDuplicate) throws ApiException {
        okhttp3.Call localVarCall = addMediaFileValidateBeforeCall(v, jobId, contentLength, body, isDuplicate, null);
        Type localVarReturnType = new TypeToken<AddMediaResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Add a piece of media to an existing job using a local file. No content-type should be included in the HTTP header. The media should be uploaded as raw binary, no encoding (base64, hex, etc) is required. Chunk-transfer encoding is NOT supported. File size is limited to 10 gb
     * @param v  (required)
     * @param jobId  (required)
     * @param contentLength  (required)
     * @param body  (required)
     * @param isDuplicate  (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addMediaFileAsync(Integer v, String jobId, Integer contentLength, File body, String isDuplicate, final ApiCallback<AddMediaResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = addMediaFileValidateBeforeCall(v, jobId, contentLength, body, isDuplicate, _callback);
        Type localVarReturnType = new TypeToken<AddMediaResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for addMediaUrl
     * @param v  (required)
     * @param jobId  (required)
     * @param mediaUrl  (required)
     * @param isDuplicate  (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addMediaUrlCall(Integer v, String jobId, String mediaUrl, String isDuplicate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/job/add_media";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (v != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("v", v));
        }

        if (jobId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("job_id", jobId));
        }

        if (mediaUrl != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("media_url", mediaUrl));
        }

        if (isDuplicate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("is_duplicate", isDuplicate));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call addMediaUrlValidateBeforeCall(Integer v, String jobId, String mediaUrl, String isDuplicate, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'v' is set
        if (v == null) {
            throw new ApiException("Missing the required parameter 'v' when calling addMediaUrl(Async)");
        }
        
        // verify the required parameter 'jobId' is set
        if (jobId == null) {
            throw new ApiException("Missing the required parameter 'jobId' when calling addMediaUrl(Async)");
        }
        
        // verify the required parameter 'mediaUrl' is set
        if (mediaUrl == null) {
            throw new ApiException("Missing the required parameter 'mediaUrl' when calling addMediaUrl(Async)");
        }
        

        okhttp3.Call localVarCall = addMediaUrlCall(v, jobId, mediaUrl, isDuplicate, _callback);
        return localVarCall;

    }

    /**
     * 
     * Add a piece of media to an existing job using a public media url. A job may only have a single piece of media associated with it, attempting to add additional media will return an error code.
     * @param v  (required)
     * @param jobId  (required)
     * @param mediaUrl  (required)
     * @param isDuplicate  (optional, default to false)
     * @return AddMediaResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public AddMediaResponse addMediaUrl(Integer v, String jobId, String mediaUrl, String isDuplicate) throws ApiException {
        ApiResponse<AddMediaResponse> localVarResp = addMediaUrlWithHttpInfo(v, jobId, mediaUrl, isDuplicate);
        return localVarResp.getData();
    }

    /**
     * 
     * Add a piece of media to an existing job using a public media url. A job may only have a single piece of media associated with it, attempting to add additional media will return an error code.
     * @param v  (required)
     * @param jobId  (required)
     * @param mediaUrl  (required)
     * @param isDuplicate  (optional, default to false)
     * @return ApiResponse&lt;AddMediaResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AddMediaResponse> addMediaUrlWithHttpInfo(Integer v, String jobId, String mediaUrl, String isDuplicate) throws ApiException {
        okhttp3.Call localVarCall = addMediaUrlValidateBeforeCall(v, jobId, mediaUrl, isDuplicate, null);
        Type localVarReturnType = new TypeToken<AddMediaResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Add a piece of media to an existing job using a public media url. A job may only have a single piece of media associated with it, attempting to add additional media will return an error code.
     * @param v  (required)
     * @param jobId  (required)
     * @param mediaUrl  (required)
     * @param isDuplicate  (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addMediaUrlAsync(Integer v, String jobId, String mediaUrl, String isDuplicate, final ApiCallback<AddMediaResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = addMediaUrlValidateBeforeCall(v, jobId, mediaUrl, isDuplicate, _callback);
        Type localVarReturnType = new TypeToken<AddMediaResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for authorizeJob
     * @param v  (required)
     * @param jobId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call authorizeJobCall(Integer v, String jobId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/job/authorize";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (v != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("v", v));
        }

        if (jobId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("job_id", jobId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call authorizeJobValidateBeforeCall(Integer v, String jobId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'v' is set
        if (v == null) {
            throw new ApiException("Missing the required parameter 'v' when calling authorizeJob(Async)");
        }
        
        // verify the required parameter 'jobId' is set
        if (jobId == null) {
            throw new ApiException("Missing the required parameter 'jobId' when calling authorizeJob(Async)");
        }
        

        okhttp3.Call localVarCall = authorizeJobCall(v, jobId, _callback);
        return localVarCall;

    }

    /**
     * 
     * Authorize an existing job. If your account has the \&quot;customer authorization\&quot; feature enabled (it is not enabled by default) jobs you create will be held in the \&quot;Authorizing\&quot; state until you call this method. Calling this method on a job that is not the \&quot;Authorizing\&quot; state has no effect and will return success. Please contact support@cielo24.com to enable the \&quot;customer authorization\&quot; feature.
     * @param v  (required)
     * @param jobId  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public void authorizeJob(Integer v, String jobId) throws ApiException {
        authorizeJobWithHttpInfo(v, jobId);
    }

    /**
     * 
     * Authorize an existing job. If your account has the \&quot;customer authorization\&quot; feature enabled (it is not enabled by default) jobs you create will be held in the \&quot;Authorizing\&quot; state until you call this method. Calling this method on a job that is not the \&quot;Authorizing\&quot; state has no effect and will return success. Please contact support@cielo24.com to enable the \&quot;customer authorization\&quot; feature.
     * @param v  (required)
     * @param jobId  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> authorizeJobWithHttpInfo(Integer v, String jobId) throws ApiException {
        okhttp3.Call localVarCall = authorizeJobValidateBeforeCall(v, jobId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Authorize an existing job. If your account has the \&quot;customer authorization\&quot; feature enabled (it is not enabled by default) jobs you create will be held in the \&quot;Authorizing\&quot; state until you call this method. Calling this method on a job that is not the \&quot;Authorizing\&quot; state has no effect and will return success. Please contact support@cielo24.com to enable the \&quot;customer authorization\&quot; feature.
     * @param v  (required)
     * @param jobId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call authorizeJobAsync(Integer v, String jobId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = authorizeJobValidateBeforeCall(v, jobId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCaption
     * @param v  (required)
     * @param jobId  (required)
     * @param captionFormat  (required)
     * @param buildUrl Rather than returning the file, return a permanent URL to the file. (optional, default to false)
     * @param captionWordsMin Minimum number of words allowed in a caption. (optional, default to 1)
     * @param captionBySentence When true, puts each sentence into its own caption. When false, more than one sentence may appear in a single caption. (optional, default to true)
     * @param charactersPerCaptionLine Maximum number of characters to be displayed on each caption line. (optional, default to 42)
     * @param dfxpHeader Allows you to specify a custom header for your DFXP caption file. The header should be the entire contents of the header including the opening and closing tags. Ignored if caption_format does not equal DFXP. (optional, default to )
     * @param disallowDangling Will prevent captions from having the last word in a sentence start a new line. Last words will ALWAYS be kept on the same line, even if it breaks the characters_per_caption_line option. (optional, default to false)
     * @param displayEffectsSpeakerAs Determines what speaker name should used for sound effects. (optional, default to Effects)
     * @param displaySpeakerId Determines the way speakers are identified in the captions. Choose \&quot;no\&quot; to not display speaker identities at all: \&quot;&gt;&gt; example\&quot; Choose \&quot;number\&quot; to display only the speaker number: \&quot;&gt;&gt; Speaker 1: example\&quot; Choose \&quot;name\&quot; to display the speaker name: \&quot;&gt;&gt; John Doe: example\&quot;. If you choose \&quot;name\&quot;, the speaker number will be displayed if the name is not available. (optional, default to name)
     * @param iwpName The named version of element list to generate the transcript from. If not specified, the transcript will be generated from the latest version. (optional, default to )
     * @param elementlistVersion The version of element list to generate the captions from. If not specified, the caption will be generated from the latest version. (ISO 8601 Date String) (optional, default to )
     * @param emitSpeakerChangeTokensAs Determine what characters to use to denote speaker changes. (optional, default to &gt;&gt;)
     * @param forceCase Force the contents of the captions to be all UPPER or lower case. If blank, the case of the captions is not changed. (optional, default to )
     * @param includeDfxpMetadata When true, and the caption format requested is DFXP, the jobs name, ID and language will be added to the DFXP metadata header. When false, these data are omitted from the header. Ignored if caption_format does not equal DFXP. (optional, default to true)
     * @param layoutTargetCaptionLengthMs Captions generated will, on average, be this duration. However, they may vary significantly based on other parameters you set. (optional, default to 5000)
     * @param lineBreakOnSentence Inserts a line break in between sentences that are in the same caption. (optional, default to false)
     * @param lineEndingFormat Determine the end of line (EOL) character to use for the captions. (optional, default to UNIX)
     * @param linesPerCaption Number of lines to be displayed for each caption. (optional, default to 2)
     * @param maskProfanity Replace profanity with asterisks. (optional, default to false)
     * @param maximumCaptionDuration No captions longer than this (in milliseconds) will be produced. If not specified, there is no maximum. (optional)
     * @param mergeGapInterval Captions with a gap between them that is smaller than this (in milliseconds) will have their start and/or end times changed so there is no time gap between the captions. (optional, default to 1000)
     * @param minimumCaptionLengthMs Extends the duration of short captions to the this minimum length. Additional time is taken from later caption blocks to meet this minimum time. (optional)
     * @param minimumGapBetweenCaptionsMs Adds a minimum time between captions such as there will always be some time between captions where no text is displayed. When captions are very close together, time will be removed from the caption duration to make the gap. (optional)
     * @param qtSeamless Does not put time gaps of any kind between caption blocks. Ignored if caption_format does not equal QT. (optional, default to false)
     * @param removeDisfluencies Remove verbal disfluencies from the generated transcript. Common disfluencies such as \&quot;um\&quot; and \&quot;ah\&quot; are removed while maintaining appropriate punctuation. (optional, default to true)
     * @param removeSoundsList A list of sounds to not show in the caption. This is a JSON style list, and should look like [\&quot;MUSIC\&quot;, \&quot;LAUGH\&quot;]. Ignored if remove_sound_references is true. (optional)
     * @param removeSoundReferences Remove ALL non-verbal sound and noise references from the generated transcript. Sounds and unidentified noises are depicted in the caption as [SOUND], [COUGH] and [NOISE]. If this parameter is set, these identifiers are omitted from the caption. (optional, default to true)
     * @param replaceSlang Replace common slang terms from the generated transcript. Common replacements are \&quot;want to\&quot; for \&quot;wanna\&quot;, \&quot;going to\&quot; for \&quot;gonna\&quot;, etc. (optional, default to false)
     * @param silenceMaxMs If there is a interval of silence in the middle of a sentence longer than this, then the caption will be split. (optional, default to 2000)
     * @param singleSpeakerPerCaption When true, puts each speaker into its own caption. When false, more than one speaker may appear in a single caption. (optional, default to true)
     * @param soundBoundaries Specifies the characters to surround sound references with. The default will generate sound references that look like this: [MUSIC]. (optional)
     * @param soundThreshold Sound references that are longer than this threshold will be made their own caption entirely, and will not have any text included with them. If not set, Sound references will be included back to back with text no matter the duration of the sound. (optional)
     * @param soundTokensByCaption If true, all sound references will always be in their own caption. If false, more than one sound reference may appear in a single caption. (optional, default to false)
     * @param soundTokensByLine If true, all sound references will always be in their own line. If false, more than one sound reference may appear in a single line. (optional, default to false)
     * @param soundTokensByCaptionList If non-empty, the specified sound references will always be in their own caption. If empty, more than one sound reference may appear in a single caption. Ignored if sound_tokens_by_caption is true. (optional)
     * @param soundTokensByLineList If non-empty, the specified sound references will always be in their own line. If empty, more than one sound reference may appear in a single line. Ignored if sound_tokens_by_line is true. (optional)
     * @param speakerOnNewLine If true, a speaker change will cause a new caption to be made. If false, multiple speakers may appear in a single caption. (optional, default to true)
     * @param srtFormat If the caption format is SRT, determines what the caption blocks will look like. The default, prints caption blocks that look like this:    1:   00:00:06,060 --&gt; 00:00:16,060   This is the caption text.  You can alter the caption block by re-arranging or removing the substitution string values, shown enclosed in braces \&quot;{}\&quot; in the default value below. Substitution strings may used more than once if desired. Any text that is not a substitution string will be displayed as written. To add new lines, include a \\n. Note, you may need to escape the \\n with an extra backslash when encoding the request.  (optional, default to {caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} --&gt;{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n)
     * @param stripSquareBrackets Removes all square brackets like &#39;[&#39; or &#39;]&#39; from captions. By default square brackets surround sound references like &#39;[MUSIC]&#39;, but they may exist as part of the caption text as well. (optional, default to false)
     * @param utf8Mark Adds a utf8 bytemark to the beginning of the caption. This should only be used if the system you are loading the caption files into needs a byte marker. The vast majority of systems do not. (optional, default to false)
     * @param replaceEnglishSpelling Replaces English spelling with location accurate spelling. i.e. Color --&gt; Colour  A: American  B: British  Z: British ize  U: Australian  C: Canadian  (optional, default to A)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCaptionCall(Integer v, String jobId, String captionFormat, String buildUrl, Integer captionWordsMin, String captionBySentence, Integer charactersPerCaptionLine, String dfxpHeader, String disallowDangling, String displayEffectsSpeakerAs, String displaySpeakerId, String iwpName, String elementlistVersion, String emitSpeakerChangeTokensAs, String forceCase, String includeDfxpMetadata, Integer layoutTargetCaptionLengthMs, String lineBreakOnSentence, String lineEndingFormat, Integer linesPerCaption, String maskProfanity, Integer maximumCaptionDuration, Integer mergeGapInterval, Integer minimumCaptionLengthMs, Integer minimumGapBetweenCaptionsMs, String qtSeamless, String removeDisfluencies, List<String> removeSoundsList, String removeSoundReferences, String replaceSlang, Integer silenceMaxMs, String singleSpeakerPerCaption, List<String> soundBoundaries, Integer soundThreshold, String soundTokensByCaption, String soundTokensByLine, List<String> soundTokensByCaptionList, List<String> soundTokensByLineList, String speakerOnNewLine, String srtFormat, String stripSquareBrackets, String utf8Mark, String replaceEnglishSpelling, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/job/get_caption";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (v != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("v", v));
        }

        if (jobId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("job_id", jobId));
        }

        if (captionFormat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("caption_format", captionFormat));
        }

        if (buildUrl != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("build_url", buildUrl));
        }

        if (captionWordsMin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("caption_words_min", captionWordsMin));
        }

        if (captionBySentence != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("caption_by_sentence", captionBySentence));
        }

        if (charactersPerCaptionLine != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("characters_per_caption_line", charactersPerCaptionLine));
        }

        if (dfxpHeader != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dfxp_header", dfxpHeader));
        }

        if (disallowDangling != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("disallow_dangling", disallowDangling));
        }

        if (displayEffectsSpeakerAs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("display_effects_speaker_as", displayEffectsSpeakerAs));
        }

        if (displaySpeakerId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("display_speaker_id", displaySpeakerId));
        }

        if (iwpName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("iwp_name", iwpName));
        }

        if (elementlistVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("elementlist_version", elementlistVersion));
        }

        if (emitSpeakerChangeTokensAs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("emit_speaker_change_tokens_as", emitSpeakerChangeTokensAs));
        }

        if (forceCase != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("force_case", forceCase));
        }

        if (includeDfxpMetadata != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_dfxp_metadata", includeDfxpMetadata));
        }

        if (layoutTargetCaptionLengthMs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("layout_target_caption_length_ms", layoutTargetCaptionLengthMs));
        }

        if (lineBreakOnSentence != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("line_break_on_sentence", lineBreakOnSentence));
        }

        if (lineEndingFormat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("line_ending_format", lineEndingFormat));
        }

        if (linesPerCaption != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lines_per_caption", linesPerCaption));
        }

        if (maskProfanity != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mask_profanity", maskProfanity));
        }

        if (maximumCaptionDuration != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maximum_caption_duration", maximumCaptionDuration));
        }

        if (mergeGapInterval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("merge_gap_interval", mergeGapInterval));
        }

        if (minimumCaptionLengthMs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minimum_caption_length_ms", minimumCaptionLengthMs));
        }

        if (minimumGapBetweenCaptionsMs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minimum_gap_between_captions_ms", minimumGapBetweenCaptionsMs));
        }

        if (qtSeamless != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("qt_seamless", qtSeamless));
        }

        if (removeDisfluencies != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("remove_disfluencies", removeDisfluencies));
        }

        if (removeSoundsList != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "remove_sounds_list", removeSoundsList));
        }

        if (removeSoundReferences != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("remove_sound_references", removeSoundReferences));
        }

        if (replaceSlang != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("replace_slang", replaceSlang));
        }

        if (silenceMaxMs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("silence_max_ms", silenceMaxMs));
        }

        if (singleSpeakerPerCaption != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("single_speaker_per_caption", singleSpeakerPerCaption));
        }

        if (soundBoundaries != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "sound_boundaries", soundBoundaries));
        }

        if (soundThreshold != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sound_threshold", soundThreshold));
        }

        if (soundTokensByCaption != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sound_tokens_by_caption", soundTokensByCaption));
        }

        if (soundTokensByLine != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sound_tokens_by_line", soundTokensByLine));
        }

        if (soundTokensByCaptionList != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "sound_tokens_by_caption_list", soundTokensByCaptionList));
        }

        if (soundTokensByLineList != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "sound_tokens_by_line_list", soundTokensByLineList));
        }

        if (speakerOnNewLine != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("speaker_on_new_line", speakerOnNewLine));
        }

        if (srtFormat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("srt_format", srtFormat));
        }

        if (stripSquareBrackets != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("strip_square_brackets", stripSquareBrackets));
        }

        if (utf8Mark != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("utf8_mark", utf8Mark));
        }

        if (replaceEnglishSpelling != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("replace_english_spelling", replaceEnglishSpelling));
        }

        final String[] localVarAccepts = {
            "text/plain", "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCaptionValidateBeforeCall(Integer v, String jobId, String captionFormat, String buildUrl, Integer captionWordsMin, String captionBySentence, Integer charactersPerCaptionLine, String dfxpHeader, String disallowDangling, String displayEffectsSpeakerAs, String displaySpeakerId, String iwpName, String elementlistVersion, String emitSpeakerChangeTokensAs, String forceCase, String includeDfxpMetadata, Integer layoutTargetCaptionLengthMs, String lineBreakOnSentence, String lineEndingFormat, Integer linesPerCaption, String maskProfanity, Integer maximumCaptionDuration, Integer mergeGapInterval, Integer minimumCaptionLengthMs, Integer minimumGapBetweenCaptionsMs, String qtSeamless, String removeDisfluencies, List<String> removeSoundsList, String removeSoundReferences, String replaceSlang, Integer silenceMaxMs, String singleSpeakerPerCaption, List<String> soundBoundaries, Integer soundThreshold, String soundTokensByCaption, String soundTokensByLine, List<String> soundTokensByCaptionList, List<String> soundTokensByLineList, String speakerOnNewLine, String srtFormat, String stripSquareBrackets, String utf8Mark, String replaceEnglishSpelling, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'v' is set
        if (v == null) {
            throw new ApiException("Missing the required parameter 'v' when calling getCaption(Async)");
        }
        
        // verify the required parameter 'jobId' is set
        if (jobId == null) {
            throw new ApiException("Missing the required parameter 'jobId' when calling getCaption(Async)");
        }
        
        // verify the required parameter 'captionFormat' is set
        if (captionFormat == null) {
            throw new ApiException("Missing the required parameter 'captionFormat' when calling getCaption(Async)");
        }
        

        okhttp3.Call localVarCall = getCaptionCall(v, jobId, captionFormat, buildUrl, captionWordsMin, captionBySentence, charactersPerCaptionLine, dfxpHeader, disallowDangling, displayEffectsSpeakerAs, displaySpeakerId, iwpName, elementlistVersion, emitSpeakerChangeTokensAs, forceCase, includeDfxpMetadata, layoutTargetCaptionLengthMs, lineBreakOnSentence, lineEndingFormat, linesPerCaption, maskProfanity, maximumCaptionDuration, mergeGapInterval, minimumCaptionLengthMs, minimumGapBetweenCaptionsMs, qtSeamless, removeDisfluencies, removeSoundsList, removeSoundReferences, replaceSlang, silenceMaxMs, singleSpeakerPerCaption, soundBoundaries, soundThreshold, soundTokensByCaption, soundTokensByLine, soundTokensByCaptionList, soundTokensByLineList, speakerOnNewLine, srtFormat, stripSquareBrackets, utf8Mark, replaceEnglishSpelling, _callback);
        return localVarCall;

    }

    /**
     * 
     * Get the caption file for a job. The job must have completed transcription before a caption can be downloaded.
     * @param v  (required)
     * @param jobId  (required)
     * @param captionFormat  (required)
     * @param buildUrl Rather than returning the file, return a permanent URL to the file. (optional, default to false)
     * @param captionWordsMin Minimum number of words allowed in a caption. (optional, default to 1)
     * @param captionBySentence When true, puts each sentence into its own caption. When false, more than one sentence may appear in a single caption. (optional, default to true)
     * @param charactersPerCaptionLine Maximum number of characters to be displayed on each caption line. (optional, default to 42)
     * @param dfxpHeader Allows you to specify a custom header for your DFXP caption file. The header should be the entire contents of the header including the opening and closing tags. Ignored if caption_format does not equal DFXP. (optional, default to )
     * @param disallowDangling Will prevent captions from having the last word in a sentence start a new line. Last words will ALWAYS be kept on the same line, even if it breaks the characters_per_caption_line option. (optional, default to false)
     * @param displayEffectsSpeakerAs Determines what speaker name should used for sound effects. (optional, default to Effects)
     * @param displaySpeakerId Determines the way speakers are identified in the captions. Choose \&quot;no\&quot; to not display speaker identities at all: \&quot;&gt;&gt; example\&quot; Choose \&quot;number\&quot; to display only the speaker number: \&quot;&gt;&gt; Speaker 1: example\&quot; Choose \&quot;name\&quot; to display the speaker name: \&quot;&gt;&gt; John Doe: example\&quot;. If you choose \&quot;name\&quot;, the speaker number will be displayed if the name is not available. (optional, default to name)
     * @param iwpName The named version of element list to generate the transcript from. If not specified, the transcript will be generated from the latest version. (optional, default to )
     * @param elementlistVersion The version of element list to generate the captions from. If not specified, the caption will be generated from the latest version. (ISO 8601 Date String) (optional, default to )
     * @param emitSpeakerChangeTokensAs Determine what characters to use to denote speaker changes. (optional, default to &gt;&gt;)
     * @param forceCase Force the contents of the captions to be all UPPER or lower case. If blank, the case of the captions is not changed. (optional, default to )
     * @param includeDfxpMetadata When true, and the caption format requested is DFXP, the jobs name, ID and language will be added to the DFXP metadata header. When false, these data are omitted from the header. Ignored if caption_format does not equal DFXP. (optional, default to true)
     * @param layoutTargetCaptionLengthMs Captions generated will, on average, be this duration. However, they may vary significantly based on other parameters you set. (optional, default to 5000)
     * @param lineBreakOnSentence Inserts a line break in between sentences that are in the same caption. (optional, default to false)
     * @param lineEndingFormat Determine the end of line (EOL) character to use for the captions. (optional, default to UNIX)
     * @param linesPerCaption Number of lines to be displayed for each caption. (optional, default to 2)
     * @param maskProfanity Replace profanity with asterisks. (optional, default to false)
     * @param maximumCaptionDuration No captions longer than this (in milliseconds) will be produced. If not specified, there is no maximum. (optional)
     * @param mergeGapInterval Captions with a gap between them that is smaller than this (in milliseconds) will have their start and/or end times changed so there is no time gap between the captions. (optional, default to 1000)
     * @param minimumCaptionLengthMs Extends the duration of short captions to the this minimum length. Additional time is taken from later caption blocks to meet this minimum time. (optional)
     * @param minimumGapBetweenCaptionsMs Adds a minimum time between captions such as there will always be some time between captions where no text is displayed. When captions are very close together, time will be removed from the caption duration to make the gap. (optional)
     * @param qtSeamless Does not put time gaps of any kind between caption blocks. Ignored if caption_format does not equal QT. (optional, default to false)
     * @param removeDisfluencies Remove verbal disfluencies from the generated transcript. Common disfluencies such as \&quot;um\&quot; and \&quot;ah\&quot; are removed while maintaining appropriate punctuation. (optional, default to true)
     * @param removeSoundsList A list of sounds to not show in the caption. This is a JSON style list, and should look like [\&quot;MUSIC\&quot;, \&quot;LAUGH\&quot;]. Ignored if remove_sound_references is true. (optional)
     * @param removeSoundReferences Remove ALL non-verbal sound and noise references from the generated transcript. Sounds and unidentified noises are depicted in the caption as [SOUND], [COUGH] and [NOISE]. If this parameter is set, these identifiers are omitted from the caption. (optional, default to true)
     * @param replaceSlang Replace common slang terms from the generated transcript. Common replacements are \&quot;want to\&quot; for \&quot;wanna\&quot;, \&quot;going to\&quot; for \&quot;gonna\&quot;, etc. (optional, default to false)
     * @param silenceMaxMs If there is a interval of silence in the middle of a sentence longer than this, then the caption will be split. (optional, default to 2000)
     * @param singleSpeakerPerCaption When true, puts each speaker into its own caption. When false, more than one speaker may appear in a single caption. (optional, default to true)
     * @param soundBoundaries Specifies the characters to surround sound references with. The default will generate sound references that look like this: [MUSIC]. (optional)
     * @param soundThreshold Sound references that are longer than this threshold will be made their own caption entirely, and will not have any text included with them. If not set, Sound references will be included back to back with text no matter the duration of the sound. (optional)
     * @param soundTokensByCaption If true, all sound references will always be in their own caption. If false, more than one sound reference may appear in a single caption. (optional, default to false)
     * @param soundTokensByLine If true, all sound references will always be in their own line. If false, more than one sound reference may appear in a single line. (optional, default to false)
     * @param soundTokensByCaptionList If non-empty, the specified sound references will always be in their own caption. If empty, more than one sound reference may appear in a single caption. Ignored if sound_tokens_by_caption is true. (optional)
     * @param soundTokensByLineList If non-empty, the specified sound references will always be in their own line. If empty, more than one sound reference may appear in a single line. Ignored if sound_tokens_by_line is true. (optional)
     * @param speakerOnNewLine If true, a speaker change will cause a new caption to be made. If false, multiple speakers may appear in a single caption. (optional, default to true)
     * @param srtFormat If the caption format is SRT, determines what the caption blocks will look like. The default, prints caption blocks that look like this:    1:   00:00:06,060 --&gt; 00:00:16,060   This is the caption text.  You can alter the caption block by re-arranging or removing the substitution string values, shown enclosed in braces \&quot;{}\&quot; in the default value below. Substitution strings may used more than once if desired. Any text that is not a substitution string will be displayed as written. To add new lines, include a \\n. Note, you may need to escape the \\n with an extra backslash when encoding the request.  (optional, default to {caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} --&gt;{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n)
     * @param stripSquareBrackets Removes all square brackets like &#39;[&#39; or &#39;]&#39; from captions. By default square brackets surround sound references like &#39;[MUSIC]&#39;, but they may exist as part of the caption text as well. (optional, default to false)
     * @param utf8Mark Adds a utf8 bytemark to the beginning of the caption. This should only be used if the system you are loading the caption files into needs a byte marker. The vast majority of systems do not. (optional, default to false)
     * @param replaceEnglishSpelling Replaces English spelling with location accurate spelling. i.e. Color --&gt; Colour  A: American  B: British  Z: British ize  U: Australian  C: Canadian  (optional, default to A)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public String getCaption(Integer v, String jobId, String captionFormat, String buildUrl, Integer captionWordsMin, String captionBySentence, Integer charactersPerCaptionLine, String dfxpHeader, String disallowDangling, String displayEffectsSpeakerAs, String displaySpeakerId, String iwpName, String elementlistVersion, String emitSpeakerChangeTokensAs, String forceCase, String includeDfxpMetadata, Integer layoutTargetCaptionLengthMs, String lineBreakOnSentence, String lineEndingFormat, Integer linesPerCaption, String maskProfanity, Integer maximumCaptionDuration, Integer mergeGapInterval, Integer minimumCaptionLengthMs, Integer minimumGapBetweenCaptionsMs, String qtSeamless, String removeDisfluencies, List<String> removeSoundsList, String removeSoundReferences, String replaceSlang, Integer silenceMaxMs, String singleSpeakerPerCaption, List<String> soundBoundaries, Integer soundThreshold, String soundTokensByCaption, String soundTokensByLine, List<String> soundTokensByCaptionList, List<String> soundTokensByLineList, String speakerOnNewLine, String srtFormat, String stripSquareBrackets, String utf8Mark, String replaceEnglishSpelling) throws ApiException {
        ApiResponse<String> localVarResp = getCaptionWithHttpInfo(v, jobId, captionFormat, buildUrl, captionWordsMin, captionBySentence, charactersPerCaptionLine, dfxpHeader, disallowDangling, displayEffectsSpeakerAs, displaySpeakerId, iwpName, elementlistVersion, emitSpeakerChangeTokensAs, forceCase, includeDfxpMetadata, layoutTargetCaptionLengthMs, lineBreakOnSentence, lineEndingFormat, linesPerCaption, maskProfanity, maximumCaptionDuration, mergeGapInterval, minimumCaptionLengthMs, minimumGapBetweenCaptionsMs, qtSeamless, removeDisfluencies, removeSoundsList, removeSoundReferences, replaceSlang, silenceMaxMs, singleSpeakerPerCaption, soundBoundaries, soundThreshold, soundTokensByCaption, soundTokensByLine, soundTokensByCaptionList, soundTokensByLineList, speakerOnNewLine, srtFormat, stripSquareBrackets, utf8Mark, replaceEnglishSpelling);
        return localVarResp.getData();
    }

    /**
     * 
     * Get the caption file for a job. The job must have completed transcription before a caption can be downloaded.
     * @param v  (required)
     * @param jobId  (required)
     * @param captionFormat  (required)
     * @param buildUrl Rather than returning the file, return a permanent URL to the file. (optional, default to false)
     * @param captionWordsMin Minimum number of words allowed in a caption. (optional, default to 1)
     * @param captionBySentence When true, puts each sentence into its own caption. When false, more than one sentence may appear in a single caption. (optional, default to true)
     * @param charactersPerCaptionLine Maximum number of characters to be displayed on each caption line. (optional, default to 42)
     * @param dfxpHeader Allows you to specify a custom header for your DFXP caption file. The header should be the entire contents of the header including the opening and closing tags. Ignored if caption_format does not equal DFXP. (optional, default to )
     * @param disallowDangling Will prevent captions from having the last word in a sentence start a new line. Last words will ALWAYS be kept on the same line, even if it breaks the characters_per_caption_line option. (optional, default to false)
     * @param displayEffectsSpeakerAs Determines what speaker name should used for sound effects. (optional, default to Effects)
     * @param displaySpeakerId Determines the way speakers are identified in the captions. Choose \&quot;no\&quot; to not display speaker identities at all: \&quot;&gt;&gt; example\&quot; Choose \&quot;number\&quot; to display only the speaker number: \&quot;&gt;&gt; Speaker 1: example\&quot; Choose \&quot;name\&quot; to display the speaker name: \&quot;&gt;&gt; John Doe: example\&quot;. If you choose \&quot;name\&quot;, the speaker number will be displayed if the name is not available. (optional, default to name)
     * @param iwpName The named version of element list to generate the transcript from. If not specified, the transcript will be generated from the latest version. (optional, default to )
     * @param elementlistVersion The version of element list to generate the captions from. If not specified, the caption will be generated from the latest version. (ISO 8601 Date String) (optional, default to )
     * @param emitSpeakerChangeTokensAs Determine what characters to use to denote speaker changes. (optional, default to &gt;&gt;)
     * @param forceCase Force the contents of the captions to be all UPPER or lower case. If blank, the case of the captions is not changed. (optional, default to )
     * @param includeDfxpMetadata When true, and the caption format requested is DFXP, the jobs name, ID and language will be added to the DFXP metadata header. When false, these data are omitted from the header. Ignored if caption_format does not equal DFXP. (optional, default to true)
     * @param layoutTargetCaptionLengthMs Captions generated will, on average, be this duration. However, they may vary significantly based on other parameters you set. (optional, default to 5000)
     * @param lineBreakOnSentence Inserts a line break in between sentences that are in the same caption. (optional, default to false)
     * @param lineEndingFormat Determine the end of line (EOL) character to use for the captions. (optional, default to UNIX)
     * @param linesPerCaption Number of lines to be displayed for each caption. (optional, default to 2)
     * @param maskProfanity Replace profanity with asterisks. (optional, default to false)
     * @param maximumCaptionDuration No captions longer than this (in milliseconds) will be produced. If not specified, there is no maximum. (optional)
     * @param mergeGapInterval Captions with a gap between them that is smaller than this (in milliseconds) will have their start and/or end times changed so there is no time gap between the captions. (optional, default to 1000)
     * @param minimumCaptionLengthMs Extends the duration of short captions to the this minimum length. Additional time is taken from later caption blocks to meet this minimum time. (optional)
     * @param minimumGapBetweenCaptionsMs Adds a minimum time between captions such as there will always be some time between captions where no text is displayed. When captions are very close together, time will be removed from the caption duration to make the gap. (optional)
     * @param qtSeamless Does not put time gaps of any kind between caption blocks. Ignored if caption_format does not equal QT. (optional, default to false)
     * @param removeDisfluencies Remove verbal disfluencies from the generated transcript. Common disfluencies such as \&quot;um\&quot; and \&quot;ah\&quot; are removed while maintaining appropriate punctuation. (optional, default to true)
     * @param removeSoundsList A list of sounds to not show in the caption. This is a JSON style list, and should look like [\&quot;MUSIC\&quot;, \&quot;LAUGH\&quot;]. Ignored if remove_sound_references is true. (optional)
     * @param removeSoundReferences Remove ALL non-verbal sound and noise references from the generated transcript. Sounds and unidentified noises are depicted in the caption as [SOUND], [COUGH] and [NOISE]. If this parameter is set, these identifiers are omitted from the caption. (optional, default to true)
     * @param replaceSlang Replace common slang terms from the generated transcript. Common replacements are \&quot;want to\&quot; for \&quot;wanna\&quot;, \&quot;going to\&quot; for \&quot;gonna\&quot;, etc. (optional, default to false)
     * @param silenceMaxMs If there is a interval of silence in the middle of a sentence longer than this, then the caption will be split. (optional, default to 2000)
     * @param singleSpeakerPerCaption When true, puts each speaker into its own caption. When false, more than one speaker may appear in a single caption. (optional, default to true)
     * @param soundBoundaries Specifies the characters to surround sound references with. The default will generate sound references that look like this: [MUSIC]. (optional)
     * @param soundThreshold Sound references that are longer than this threshold will be made their own caption entirely, and will not have any text included with them. If not set, Sound references will be included back to back with text no matter the duration of the sound. (optional)
     * @param soundTokensByCaption If true, all sound references will always be in their own caption. If false, more than one sound reference may appear in a single caption. (optional, default to false)
     * @param soundTokensByLine If true, all sound references will always be in their own line. If false, more than one sound reference may appear in a single line. (optional, default to false)
     * @param soundTokensByCaptionList If non-empty, the specified sound references will always be in their own caption. If empty, more than one sound reference may appear in a single caption. Ignored if sound_tokens_by_caption is true. (optional)
     * @param soundTokensByLineList If non-empty, the specified sound references will always be in their own line. If empty, more than one sound reference may appear in a single line. Ignored if sound_tokens_by_line is true. (optional)
     * @param speakerOnNewLine If true, a speaker change will cause a new caption to be made. If false, multiple speakers may appear in a single caption. (optional, default to true)
     * @param srtFormat If the caption format is SRT, determines what the caption blocks will look like. The default, prints caption blocks that look like this:    1:   00:00:06,060 --&gt; 00:00:16,060   This is the caption text.  You can alter the caption block by re-arranging or removing the substitution string values, shown enclosed in braces \&quot;{}\&quot; in the default value below. Substitution strings may used more than once if desired. Any text that is not a substitution string will be displayed as written. To add new lines, include a \\n. Note, you may need to escape the \\n with an extra backslash when encoding the request.  (optional, default to {caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} --&gt;{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n)
     * @param stripSquareBrackets Removes all square brackets like &#39;[&#39; or &#39;]&#39; from captions. By default square brackets surround sound references like &#39;[MUSIC]&#39;, but they may exist as part of the caption text as well. (optional, default to false)
     * @param utf8Mark Adds a utf8 bytemark to the beginning of the caption. This should only be used if the system you are loading the caption files into needs a byte marker. The vast majority of systems do not. (optional, default to false)
     * @param replaceEnglishSpelling Replaces English spelling with location accurate spelling. i.e. Color --&gt; Colour  A: American  B: British  Z: British ize  U: Australian  C: Canadian  (optional, default to A)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> getCaptionWithHttpInfo(Integer v, String jobId, String captionFormat, String buildUrl, Integer captionWordsMin, String captionBySentence, Integer charactersPerCaptionLine, String dfxpHeader, String disallowDangling, String displayEffectsSpeakerAs, String displaySpeakerId, String iwpName, String elementlistVersion, String emitSpeakerChangeTokensAs, String forceCase, String includeDfxpMetadata, Integer layoutTargetCaptionLengthMs, String lineBreakOnSentence, String lineEndingFormat, Integer linesPerCaption, String maskProfanity, Integer maximumCaptionDuration, Integer mergeGapInterval, Integer minimumCaptionLengthMs, Integer minimumGapBetweenCaptionsMs, String qtSeamless, String removeDisfluencies, List<String> removeSoundsList, String removeSoundReferences, String replaceSlang, Integer silenceMaxMs, String singleSpeakerPerCaption, List<String> soundBoundaries, Integer soundThreshold, String soundTokensByCaption, String soundTokensByLine, List<String> soundTokensByCaptionList, List<String> soundTokensByLineList, String speakerOnNewLine, String srtFormat, String stripSquareBrackets, String utf8Mark, String replaceEnglishSpelling) throws ApiException {
        okhttp3.Call localVarCall = getCaptionValidateBeforeCall(v, jobId, captionFormat, buildUrl, captionWordsMin, captionBySentence, charactersPerCaptionLine, dfxpHeader, disallowDangling, displayEffectsSpeakerAs, displaySpeakerId, iwpName, elementlistVersion, emitSpeakerChangeTokensAs, forceCase, includeDfxpMetadata, layoutTargetCaptionLengthMs, lineBreakOnSentence, lineEndingFormat, linesPerCaption, maskProfanity, maximumCaptionDuration, mergeGapInterval, minimumCaptionLengthMs, minimumGapBetweenCaptionsMs, qtSeamless, removeDisfluencies, removeSoundsList, removeSoundReferences, replaceSlang, silenceMaxMs, singleSpeakerPerCaption, soundBoundaries, soundThreshold, soundTokensByCaption, soundTokensByLine, soundTokensByCaptionList, soundTokensByLineList, speakerOnNewLine, srtFormat, stripSquareBrackets, utf8Mark, replaceEnglishSpelling, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Get the caption file for a job. The job must have completed transcription before a caption can be downloaded.
     * @param v  (required)
     * @param jobId  (required)
     * @param captionFormat  (required)
     * @param buildUrl Rather than returning the file, return a permanent URL to the file. (optional, default to false)
     * @param captionWordsMin Minimum number of words allowed in a caption. (optional, default to 1)
     * @param captionBySentence When true, puts each sentence into its own caption. When false, more than one sentence may appear in a single caption. (optional, default to true)
     * @param charactersPerCaptionLine Maximum number of characters to be displayed on each caption line. (optional, default to 42)
     * @param dfxpHeader Allows you to specify a custom header for your DFXP caption file. The header should be the entire contents of the header including the opening and closing tags. Ignored if caption_format does not equal DFXP. (optional, default to )
     * @param disallowDangling Will prevent captions from having the last word in a sentence start a new line. Last words will ALWAYS be kept on the same line, even if it breaks the characters_per_caption_line option. (optional, default to false)
     * @param displayEffectsSpeakerAs Determines what speaker name should used for sound effects. (optional, default to Effects)
     * @param displaySpeakerId Determines the way speakers are identified in the captions. Choose \&quot;no\&quot; to not display speaker identities at all: \&quot;&gt;&gt; example\&quot; Choose \&quot;number\&quot; to display only the speaker number: \&quot;&gt;&gt; Speaker 1: example\&quot; Choose \&quot;name\&quot; to display the speaker name: \&quot;&gt;&gt; John Doe: example\&quot;. If you choose \&quot;name\&quot;, the speaker number will be displayed if the name is not available. (optional, default to name)
     * @param iwpName The named version of element list to generate the transcript from. If not specified, the transcript will be generated from the latest version. (optional, default to )
     * @param elementlistVersion The version of element list to generate the captions from. If not specified, the caption will be generated from the latest version. (ISO 8601 Date String) (optional, default to )
     * @param emitSpeakerChangeTokensAs Determine what characters to use to denote speaker changes. (optional, default to &gt;&gt;)
     * @param forceCase Force the contents of the captions to be all UPPER or lower case. If blank, the case of the captions is not changed. (optional, default to )
     * @param includeDfxpMetadata When true, and the caption format requested is DFXP, the jobs name, ID and language will be added to the DFXP metadata header. When false, these data are omitted from the header. Ignored if caption_format does not equal DFXP. (optional, default to true)
     * @param layoutTargetCaptionLengthMs Captions generated will, on average, be this duration. However, they may vary significantly based on other parameters you set. (optional, default to 5000)
     * @param lineBreakOnSentence Inserts a line break in between sentences that are in the same caption. (optional, default to false)
     * @param lineEndingFormat Determine the end of line (EOL) character to use for the captions. (optional, default to UNIX)
     * @param linesPerCaption Number of lines to be displayed for each caption. (optional, default to 2)
     * @param maskProfanity Replace profanity with asterisks. (optional, default to false)
     * @param maximumCaptionDuration No captions longer than this (in milliseconds) will be produced. If not specified, there is no maximum. (optional)
     * @param mergeGapInterval Captions with a gap between them that is smaller than this (in milliseconds) will have their start and/or end times changed so there is no time gap between the captions. (optional, default to 1000)
     * @param minimumCaptionLengthMs Extends the duration of short captions to the this minimum length. Additional time is taken from later caption blocks to meet this minimum time. (optional)
     * @param minimumGapBetweenCaptionsMs Adds a minimum time between captions such as there will always be some time between captions where no text is displayed. When captions are very close together, time will be removed from the caption duration to make the gap. (optional)
     * @param qtSeamless Does not put time gaps of any kind between caption blocks. Ignored if caption_format does not equal QT. (optional, default to false)
     * @param removeDisfluencies Remove verbal disfluencies from the generated transcript. Common disfluencies such as \&quot;um\&quot; and \&quot;ah\&quot; are removed while maintaining appropriate punctuation. (optional, default to true)
     * @param removeSoundsList A list of sounds to not show in the caption. This is a JSON style list, and should look like [\&quot;MUSIC\&quot;, \&quot;LAUGH\&quot;]. Ignored if remove_sound_references is true. (optional)
     * @param removeSoundReferences Remove ALL non-verbal sound and noise references from the generated transcript. Sounds and unidentified noises are depicted in the caption as [SOUND], [COUGH] and [NOISE]. If this parameter is set, these identifiers are omitted from the caption. (optional, default to true)
     * @param replaceSlang Replace common slang terms from the generated transcript. Common replacements are \&quot;want to\&quot; for \&quot;wanna\&quot;, \&quot;going to\&quot; for \&quot;gonna\&quot;, etc. (optional, default to false)
     * @param silenceMaxMs If there is a interval of silence in the middle of a sentence longer than this, then the caption will be split. (optional, default to 2000)
     * @param singleSpeakerPerCaption When true, puts each speaker into its own caption. When false, more than one speaker may appear in a single caption. (optional, default to true)
     * @param soundBoundaries Specifies the characters to surround sound references with. The default will generate sound references that look like this: [MUSIC]. (optional)
     * @param soundThreshold Sound references that are longer than this threshold will be made their own caption entirely, and will not have any text included with them. If not set, Sound references will be included back to back with text no matter the duration of the sound. (optional)
     * @param soundTokensByCaption If true, all sound references will always be in their own caption. If false, more than one sound reference may appear in a single caption. (optional, default to false)
     * @param soundTokensByLine If true, all sound references will always be in their own line. If false, more than one sound reference may appear in a single line. (optional, default to false)
     * @param soundTokensByCaptionList If non-empty, the specified sound references will always be in their own caption. If empty, more than one sound reference may appear in a single caption. Ignored if sound_tokens_by_caption is true. (optional)
     * @param soundTokensByLineList If non-empty, the specified sound references will always be in their own line. If empty, more than one sound reference may appear in a single line. Ignored if sound_tokens_by_line is true. (optional)
     * @param speakerOnNewLine If true, a speaker change will cause a new caption to be made. If false, multiple speakers may appear in a single caption. (optional, default to true)
     * @param srtFormat If the caption format is SRT, determines what the caption blocks will look like. The default, prints caption blocks that look like this:    1:   00:00:06,060 --&gt; 00:00:16,060   This is the caption text.  You can alter the caption block by re-arranging or removing the substitution string values, shown enclosed in braces \&quot;{}\&quot; in the default value below. Substitution strings may used more than once if desired. Any text that is not a substitution string will be displayed as written. To add new lines, include a \\n. Note, you may need to escape the \\n with an extra backslash when encoding the request.  (optional, default to {caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} --&gt;{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n)
     * @param stripSquareBrackets Removes all square brackets like &#39;[&#39; or &#39;]&#39; from captions. By default square brackets surround sound references like &#39;[MUSIC]&#39;, but they may exist as part of the caption text as well. (optional, default to false)
     * @param utf8Mark Adds a utf8 bytemark to the beginning of the caption. This should only be used if the system you are loading the caption files into needs a byte marker. The vast majority of systems do not. (optional, default to false)
     * @param replaceEnglishSpelling Replaces English spelling with location accurate spelling. i.e. Color --&gt; Colour  A: American  B: British  Z: British ize  U: Australian  C: Canadian  (optional, default to A)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCaptionAsync(Integer v, String jobId, String captionFormat, String buildUrl, Integer captionWordsMin, String captionBySentence, Integer charactersPerCaptionLine, String dfxpHeader, String disallowDangling, String displayEffectsSpeakerAs, String displaySpeakerId, String iwpName, String elementlistVersion, String emitSpeakerChangeTokensAs, String forceCase, String includeDfxpMetadata, Integer layoutTargetCaptionLengthMs, String lineBreakOnSentence, String lineEndingFormat, Integer linesPerCaption, String maskProfanity, Integer maximumCaptionDuration, Integer mergeGapInterval, Integer minimumCaptionLengthMs, Integer minimumGapBetweenCaptionsMs, String qtSeamless, String removeDisfluencies, List<String> removeSoundsList, String removeSoundReferences, String replaceSlang, Integer silenceMaxMs, String singleSpeakerPerCaption, List<String> soundBoundaries, Integer soundThreshold, String soundTokensByCaption, String soundTokensByLine, List<String> soundTokensByCaptionList, List<String> soundTokensByLineList, String speakerOnNewLine, String srtFormat, String stripSquareBrackets, String utf8Mark, String replaceEnglishSpelling, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCaptionValidateBeforeCall(v, jobId, captionFormat, buildUrl, captionWordsMin, captionBySentence, charactersPerCaptionLine, dfxpHeader, disallowDangling, displayEffectsSpeakerAs, displaySpeakerId, iwpName, elementlistVersion, emitSpeakerChangeTokensAs, forceCase, includeDfxpMetadata, layoutTargetCaptionLengthMs, lineBreakOnSentence, lineEndingFormat, linesPerCaption, maskProfanity, maximumCaptionDuration, mergeGapInterval, minimumCaptionLengthMs, minimumGapBetweenCaptionsMs, qtSeamless, removeDisfluencies, removeSoundsList, removeSoundReferences, replaceSlang, silenceMaxMs, singleSpeakerPerCaption, soundBoundaries, soundThreshold, soundTokensByCaption, soundTokensByLine, soundTokensByCaptionList, soundTokensByLineList, speakerOnNewLine, srtFormat, stripSquareBrackets, utf8Mark, replaceEnglishSpelling, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for jobInfo
     * @param v  (required)
     * @param jobId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call jobInfoCall(Integer v, String jobId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/job/info";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (v != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("v", v));
        }

        if (jobId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("job_id", jobId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call jobInfoValidateBeforeCall(Integer v, String jobId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'v' is set
        if (v == null) {
            throw new ApiException("Missing the required parameter 'v' when calling jobInfo(Async)");
        }
        
        // verify the required parameter 'jobId' is set
        if (jobId == null) {
            throw new ApiException("Missing the required parameter 'jobId' when calling jobInfo(Async)");
        }
        

        okhttp3.Call localVarCall = jobInfoCall(v, jobId, _callback);
        return localVarCall;

    }

    /**
     * 
     * 
     * @param v  (required)
     * @param jobId  (required)
     * @return JobInfoResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public JobInfoResponse jobInfo(Integer v, String jobId) throws ApiException {
        ApiResponse<JobInfoResponse> localVarResp = jobInfoWithHttpInfo(v, jobId);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param v  (required)
     * @param jobId  (required)
     * @return ApiResponse&lt;JobInfoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<JobInfoResponse> jobInfoWithHttpInfo(Integer v, String jobId) throws ApiException {
        okhttp3.Call localVarCall = jobInfoValidateBeforeCall(v, jobId, null);
        Type localVarReturnType = new TypeToken<JobInfoResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param v  (required)
     * @param jobId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call jobInfoAsync(Integer v, String jobId, final ApiCallback<JobInfoResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = jobInfoValidateBeforeCall(v, jobId, _callback);
        Type localVarReturnType = new TypeToken<JobInfoResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for newJob
     * @param v  (required)
     * @param newJobBody  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call newJobCall(Integer v, NewJobBody newJobBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = newJobBody;

        // create path and map variables
        String localVarPath = "/job/new";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (v != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("v", v));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call newJobValidateBeforeCall(Integer v, NewJobBody newJobBody, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'v' is set
        if (v == null) {
            throw new ApiException("Missing the required parameter 'v' when calling newJob(Async)");
        }
        
        // verify the required parameter 'newJobBody' is set
        if (newJobBody == null) {
            throw new ApiException("Missing the required parameter 'newJobBody' when calling newJob(Async)");
        }
        

        okhttp3.Call localVarCall = newJobCall(v, newJobBody, _callback);
        return localVarCall;

    }

    /**
     * 
     * Create a new job. A job is a container into which you can upload media and request that transcription be performed. Creating a job is prerequisite for virtually all other methods.
     * @param v  (required)
     * @param newJobBody  (required)
     * @return NewJobResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public NewJobResponse newJob(Integer v, NewJobBody newJobBody) throws ApiException {
        ApiResponse<NewJobResponse> localVarResp = newJobWithHttpInfo(v, newJobBody);
        return localVarResp.getData();
    }

    /**
     * 
     * Create a new job. A job is a container into which you can upload media and request that transcription be performed. Creating a job is prerequisite for virtually all other methods.
     * @param v  (required)
     * @param newJobBody  (required)
     * @return ApiResponse&lt;NewJobResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NewJobResponse> newJobWithHttpInfo(Integer v, NewJobBody newJobBody) throws ApiException {
        okhttp3.Call localVarCall = newJobValidateBeforeCall(v, newJobBody, null);
        Type localVarReturnType = new TypeToken<NewJobResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Create a new job. A job is a container into which you can upload media and request that transcription be performed. Creating a job is prerequisite for virtually all other methods.
     * @param v  (required)
     * @param newJobBody  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call newJobAsync(Integer v, NewJobBody newJobBody, final ApiCallback<NewJobResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = newJobValidateBeforeCall(v, newJobBody, _callback);
        Type localVarReturnType = new TypeToken<NewJobResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for performTranscription
     * @param v  (required)
     * @param performTranscriptionBody  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call performTranscriptionCall(Integer v, PerformTranscriptionBody performTranscriptionBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = performTranscriptionBody;

        // create path and map variables
        String localVarPath = "/job/perform_transcription";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (v != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("v", v));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call performTranscriptionValidateBeforeCall(Integer v, PerformTranscriptionBody performTranscriptionBody, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'v' is set
        if (v == null) {
            throw new ApiException("Missing the required parameter 'v' when calling performTranscription(Async)");
        }
        
        // verify the required parameter 'performTranscriptionBody' is set
        if (performTranscriptionBody == null) {
            throw new ApiException("Missing the required parameter 'performTranscriptionBody' when calling performTranscription(Async)");
        }
        

        okhttp3.Call localVarCall = performTranscriptionCall(v, performTranscriptionBody, _callback);
        return localVarCall;

    }

    /**
     * 
     * Request that transcription be performed on the specified job. A callback URL, if specified, will be called when the transcription is complete. See [callback documentation](https://cielo24.readthedocs.io/en/latest/basics.html#callbacks-label) for details.
     * @param v  (required)
     * @param performTranscriptionBody  (required)
     * @return PerformTranscriptionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public PerformTranscriptionResponse performTranscription(Integer v, PerformTranscriptionBody performTranscriptionBody) throws ApiException {
        ApiResponse<PerformTranscriptionResponse> localVarResp = performTranscriptionWithHttpInfo(v, performTranscriptionBody);
        return localVarResp.getData();
    }

    /**
     * 
     * Request that transcription be performed on the specified job. A callback URL, if specified, will be called when the transcription is complete. See [callback documentation](https://cielo24.readthedocs.io/en/latest/basics.html#callbacks-label) for details.
     * @param v  (required)
     * @param performTranscriptionBody  (required)
     * @return ApiResponse&lt;PerformTranscriptionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PerformTranscriptionResponse> performTranscriptionWithHttpInfo(Integer v, PerformTranscriptionBody performTranscriptionBody) throws ApiException {
        okhttp3.Call localVarCall = performTranscriptionValidateBeforeCall(v, performTranscriptionBody, null);
        Type localVarReturnType = new TypeToken<PerformTranscriptionResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Request that transcription be performed on the specified job. A callback URL, if specified, will be called when the transcription is complete. See [callback documentation](https://cielo24.readthedocs.io/en/latest/basics.html#callbacks-label) for details.
     * @param v  (required)
     * @param performTranscriptionBody  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call performTranscriptionAsync(Integer v, PerformTranscriptionBody performTranscriptionBody, final ApiCallback<PerformTranscriptionResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = performTranscriptionValidateBeforeCall(v, performTranscriptionBody, _callback);
        Type localVarReturnType = new TypeToken<PerformTranscriptionResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for performTranslation
     * @param v  (required)
     * @param jobId  (required)
     * @param targetLanguages The language(s) being ordered (Any RFC 5646 language code) separated by comma (,) (required)
     * @param approveUplevel  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call performTranslationCall(Integer v, String jobId, String targetLanguages, String approveUplevel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/job/perform_translation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (v != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("v", v));
        }

        if (jobId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("job_id", jobId));
        }

        if (targetLanguages != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("target_languages", targetLanguages));
        }

        if (approveUplevel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("approve_uplevel", approveUplevel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call performTranslationValidateBeforeCall(Integer v, String jobId, String targetLanguages, String approveUplevel, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'v' is set
        if (v == null) {
            throw new ApiException("Missing the required parameter 'v' when calling performTranslation(Async)");
        }
        
        // verify the required parameter 'jobId' is set
        if (jobId == null) {
            throw new ApiException("Missing the required parameter 'jobId' when calling performTranslation(Async)");
        }
        
        // verify the required parameter 'targetLanguages' is set
        if (targetLanguages == null) {
            throw new ApiException("Missing the required parameter 'targetLanguages' when calling performTranslation(Async)");
        }
        

        okhttp3.Call localVarCall = performTranslationCall(v, jobId, targetLanguages, approveUplevel, _callback);
        return localVarCall;

    }

    /**
     * 
     * Request that orders a new Translation language for a video that has been previously Transcribed and/or Translated. The New Job ID and job target language will be returned upon completion.
     * @param v  (required)
     * @param jobId  (required)
     * @param targetLanguages The language(s) being ordered (Any RFC 5646 language code) separated by comma (,) (required)
     * @param approveUplevel  (optional)
     * @return PerformTranslationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public PerformTranslationResponse performTranslation(Integer v, String jobId, String targetLanguages, String approveUplevel) throws ApiException {
        ApiResponse<PerformTranslationResponse> localVarResp = performTranslationWithHttpInfo(v, jobId, targetLanguages, approveUplevel);
        return localVarResp.getData();
    }

    /**
     * 
     * Request that orders a new Translation language for a video that has been previously Transcribed and/or Translated. The New Job ID and job target language will be returned upon completion.
     * @param v  (required)
     * @param jobId  (required)
     * @param targetLanguages The language(s) being ordered (Any RFC 5646 language code) separated by comma (,) (required)
     * @param approveUplevel  (optional)
     * @return ApiResponse&lt;PerformTranslationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PerformTranslationResponse> performTranslationWithHttpInfo(Integer v, String jobId, String targetLanguages, String approveUplevel) throws ApiException {
        okhttp3.Call localVarCall = performTranslationValidateBeforeCall(v, jobId, targetLanguages, approveUplevel, null);
        Type localVarReturnType = new TypeToken<PerformTranslationResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Request that orders a new Translation language for a video that has been previously Transcribed and/or Translated. The New Job ID and job target language will be returned upon completion.
     * @param v  (required)
     * @param jobId  (required)
     * @param targetLanguages The language(s) being ordered (Any RFC 5646 language code) separated by comma (,) (required)
     * @param approveUplevel  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An error occurred </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call performTranslationAsync(Integer v, String jobId, String targetLanguages, String approveUplevel, final ApiCallback<PerformTranslationResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = performTranslationValidateBeforeCall(v, jobId, targetLanguages, approveUplevel, _callback);
        Type localVarReturnType = new TypeToken<PerformTranslationResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
